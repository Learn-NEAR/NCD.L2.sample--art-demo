{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Oleksandr Sai\\\\source\\\\repos\\\\OlexandrSai\\\\near--art--demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchJson = void 0;\n\nconst http_errors_1 = __importDefault(require(\"http-errors\"));\n\nconst exponential_backoff_1 = __importDefault(require(\"./exponential-backoff\"));\n\nconst providers_1 = require(\"../providers\");\n\nconst errors_1 = require(\"./errors\");\n\nconst START_WAIT_TIME_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst RETRY_NUMBER = 10;\n\nfunction fetchJson(_x, _x2) {\n  return _fetchJson.apply(this, arguments);\n}\n\nfunction _fetchJson() {\n  _fetchJson = _asyncToGenerator(function* (connectionInfoOrUrl, json) {\n    let connectionInfo = {\n      url: null\n    };\n\n    if (typeof connectionInfoOrUrl === 'string') {\n      connectionInfo.url = connectionInfoOrUrl;\n    } else {\n      connectionInfo = connectionInfoOrUrl;\n    }\n\n    const response = yield exponential_backoff_1.default(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, /*#__PURE__*/_asyncToGenerator(function* () {\n      try {\n        const response = yield fetch(connectionInfo.url, {\n          method: json ? 'POST' : 'GET',\n          body: json ? json : undefined,\n          headers: { ...connectionInfo.headers,\n            'Content-Type': 'application/json'\n          }\n        });\n\n        if (!response.ok) {\n          if (response.status === 503) {\n            errors_1.logWarning(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);\n            return null;\n          }\n\n          throw http_errors_1.default(response.status, yield response.text());\n        }\n\n        return response;\n      } catch (error) {\n        if (error.toString().includes('FetchError') || error.toString().includes('Failed to fetch')) {\n          errors_1.logWarning(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error}`);\n          return null;\n        }\n\n        throw error;\n      }\n    }));\n\n    if (!response) {\n      throw new providers_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, 'RetriesExceeded');\n    }\n\n    return yield response.json();\n  });\n  return _fetchJson.apply(this, arguments);\n}\n\nexports.fetchJson = fetchJson;","map":{"version":3,"sources":["C:/Users/Oleksandr Sai/source/repos/OlexandrSai/near--art--demo/node_modules/near-api-js/lib/utils/web.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","fetchJson","http_errors_1","require","exponential_backoff_1","providers_1","errors_1","START_WAIT_TIME_MS","BACKOFF_MULTIPLIER","RETRY_NUMBER","connectionInfoOrUrl","json","connectionInfo","url","response","default","fetch","method","body","undefined","headers","ok","status","logWarning","text","error","toString","includes","TypedError"],"mappings":"AAAA;;;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoB,KAAK,CAAzB;;AACA,MAAMC,aAAa,GAAGR,eAAe,CAACS,OAAO,CAAC,aAAD,CAAR,CAArC;;AACA,MAAMC,qBAAqB,GAAGV,eAAe,CAACS,OAAO,CAAC,uBAAD,CAAR,CAA7C;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMI,kBAAkB,GAAG,IAA3B;AACA,MAAMC,kBAAkB,GAAG,GAA3B;AACA,MAAMC,YAAY,GAAG,EAArB;;SACeR,S;;;;;iCAAf,WAAyBS,mBAAzB,EAA8CC,IAA9C,EAAoD;AAChD,QAAIC,cAAc,GAAG;AAAEC,MAAAA,GAAG,EAAE;AAAP,KAArB;;AACA,QAAI,OAAQH,mBAAR,KAAiC,QAArC,EAA+C;AAC3CE,MAAAA,cAAc,CAACC,GAAf,GAAqBH,mBAArB;AACH,KAFD,MAGK;AACDE,MAAAA,cAAc,GAAGF,mBAAjB;AACH;;AACD,UAAMI,QAAQ,SAASV,qBAAqB,CAACW,OAAtB,CAA8BR,kBAA9B,EAAkDE,YAAlD,EAAgED,kBAAhE,iCAAoF,aAAY;AACnH,UAAI;AACA,cAAMM,QAAQ,SAASE,KAAK,CAACJ,cAAc,CAACC,GAAhB,EAAqB;AAC7CI,UAAAA,MAAM,EAAEN,IAAI,GAAG,MAAH,GAAY,KADqB;AAE7CO,UAAAA,IAAI,EAAEP,IAAI,GAAGA,IAAH,GAAUQ,SAFyB;AAG7CC,UAAAA,OAAO,EAAE,EAAE,GAAGR,cAAc,CAACQ,OAApB;AAA6B,4BAAgB;AAA7C;AAHoC,SAArB,CAA5B;;AAKA,YAAI,CAACN,QAAQ,CAACO,EAAd,EAAkB;AACd,cAAIP,QAAQ,CAACQ,MAAT,KAAoB,GAAxB,EAA6B;AACzBhB,YAAAA,QAAQ,CAACiB,UAAT,CAAqB,6BAA4BX,cAAc,CAACC,GAAI,4BAApE;AACA,mBAAO,IAAP;AACH;;AACD,gBAAMX,aAAa,CAACa,OAAd,CAAsBD,QAAQ,CAACQ,MAA/B,QAA6CR,QAAQ,CAACU,IAAT,EAA7C,CAAN;AACH;;AACD,eAAOV,QAAP;AACH,OAdD,CAeA,OAAOW,KAAP,EAAc;AACV,YAAIA,KAAK,CAACC,QAAN,GAAiBC,QAAjB,CAA0B,YAA1B,KAA2CF,KAAK,CAACC,QAAN,GAAiBC,QAAjB,CAA0B,iBAA1B,CAA/C,EAA6F;AACzFrB,UAAAA,QAAQ,CAACiB,UAAT,CAAqB,6BAA4BX,cAAc,CAACC,GAAI,sBAAqBY,KAAM,EAA/F;AACA,iBAAO,IAAP;AACH;;AACD,cAAMA,KAAN;AACH;AACJ,KAvBsB,EAAvB;;AAwBA,QAAI,CAACX,QAAL,EAAe;AACX,YAAM,IAAIT,WAAW,CAACuB,UAAhB,CAA4B,YAAWnB,YAAa,iBAAgBG,cAAc,CAACC,GAAI,GAAvF,EAA2F,iBAA3F,CAAN;AACH;;AACD,iBAAaC,QAAQ,CAACH,IAAT,EAAb;AACH,G;;;;AACDZ,OAAO,CAACE,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchJson = void 0;\nconst http_errors_1 = __importDefault(require(\"http-errors\"));\nconst exponential_backoff_1 = __importDefault(require(\"./exponential-backoff\"));\nconst providers_1 = require(\"../providers\");\nconst errors_1 = require(\"./errors\");\nconst START_WAIT_TIME_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst RETRY_NUMBER = 10;\nasync function fetchJson(connectionInfoOrUrl, json) {\n    let connectionInfo = { url: null };\n    if (typeof (connectionInfoOrUrl) === 'string') {\n        connectionInfo.url = connectionInfoOrUrl;\n    }\n    else {\n        connectionInfo = connectionInfoOrUrl;\n    }\n    const response = await exponential_backoff_1.default(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, async () => {\n        try {\n            const response = await fetch(connectionInfo.url, {\n                method: json ? 'POST' : 'GET',\n                body: json ? json : undefined,\n                headers: { ...connectionInfo.headers, 'Content-Type': 'application/json' }\n            });\n            if (!response.ok) {\n                if (response.status === 503) {\n                    errors_1.logWarning(`Retrying HTTP request for ${connectionInfo.url} as it's not available now`);\n                    return null;\n                }\n                throw http_errors_1.default(response.status, await response.text());\n            }\n            return response;\n        }\n        catch (error) {\n            if (error.toString().includes('FetchError') || error.toString().includes('Failed to fetch')) {\n                errors_1.logWarning(`Retrying HTTP request for ${connectionInfo.url} because of error: ${error}`);\n                return null;\n            }\n            throw error;\n        }\n    });\n    if (!response) {\n        throw new providers_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${connectionInfo.url}.`, 'RetriesExceeded');\n    }\n    return await response.json();\n}\nexports.fetchJson = fetchJson;\n"]},"metadata":{},"sourceType":"script"}