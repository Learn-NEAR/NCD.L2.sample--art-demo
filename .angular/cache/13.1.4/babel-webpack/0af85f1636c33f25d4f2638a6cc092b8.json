{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Oleksandr Sai\\\\source\\\\repos\\\\OlexandrSai\\\\near--art--demo\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\n\nconst depd_1 = __importDefault(require(\"depd\"));\n\nconst account_1 = require(\"./account\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst utils_1 = require(\"./utils\");\n\nconst borsh_1 = require(\"borsh\");\n\nconst borsh_2 = require(\"borsh\");\n\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\n\nclass WalletConnection {\n  constructor(near, appKeyPrefix) {\n    this._near = near;\n    const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n    this._keyStore = near.connection.signer.keyStore;\n    this._authData = authData || {\n      allKeys: []\n    };\n    this._authDataKey = authDataKey;\n\n    if (!this.isSignedIn()) {\n      this._completeSignInWithAccessKey();\n    }\n  }\n  /**\n   * Returns true, if this WalletAccount is authorized with the wallet.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.isSignedIn();\n   * ```\n   */\n\n\n  isSignedIn() {\n    return !!this._authData.accountId;\n  }\n  /**\n   * Returns authorized Account ID.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.getAccountId();\n   * ```\n   */\n\n\n  getAccountId() {\n    return this._authData.accountId || '';\n  }\n  /**\n   * Redirects current page to the wallet authentication page.\n   * @param options An optional options object\n   * @param options.contractId The NEAR account where the contract is deployed\n   * @param options.successUrl URL to redirect upon success. Default: current url\n   * @param options.failureUrl URL to redirect upon failure. Default: current url\n   *\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * // redirects to the NEAR Wallet\n   * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n   * ```\n   */\n\n\n  requestSignIn(contractIdOrOptions = {}, title, successUrl, failureUrl) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let options;\n\n      if (typeof contractIdOrOptions === 'string') {\n        const deprecate = depd_1.default('requestSignIn(contractId, title)');\n        deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n        options = {\n          contractId: contractIdOrOptions,\n          successUrl,\n          failureUrl\n        };\n      } else {\n        options = contractIdOrOptions;\n      }\n\n      const currentUrl = new URL(window.location.href);\n      const newUrl = new URL(_this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n      newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n      newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n\n      if (options.contractId) {\n        /* Throws exception if contract account does not exist */\n        const contractAccount = yield _this._near.account(options.contractId);\n        yield contractAccount.state();\n        newUrl.searchParams.set('contract_id', options.contractId);\n        const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n        newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n        yield _this._keyStore.setKey(_this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n      }\n\n      if (options.methodNames) {\n        options.methodNames.forEach(methodName => {\n          newUrl.searchParams.append('methodNames', methodName);\n        });\n      }\n\n      window.location.assign(newUrl.toString());\n    })();\n  }\n\n  requestSignTransactions(...args) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (Array.isArray(args[0])) {\n        const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n        deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n        return _this2._requestSignTransactions({\n          transactions: args[0],\n          callbackUrl: args[1],\n          meta: args[2]\n        });\n      }\n\n      return _this2._requestSignTransactions(args[0]);\n    })();\n  }\n\n  _requestSignTransactions({\n    transactions,\n    meta,\n    callbackUrl\n  }) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const currentUrl = new URL(window.location.href);\n      const newUrl = new URL('sign', _this3._walletBaseUrl);\n      newUrl.searchParams.set('transactions', transactions.map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction)).map(serialized => Buffer.from(serialized).toString('base64')).join(','));\n      newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n      if (meta) newUrl.searchParams.set('meta', meta);\n      window.location.assign(newUrl.toString());\n    })();\n  }\n  /**\n   * @hidden\n   * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n   */\n\n\n  _completeSignInWithAccessKey() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const currentUrl = new URL(window.location.href);\n      const publicKey = currentUrl.searchParams.get('public_key') || '';\n      const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n      const accountId = currentUrl.searchParams.get('account_id') || ''; // TODO: Handle errors during login\n\n      if (accountId) {\n        _this4._authData = {\n          accountId,\n          allKeys\n        };\n        window.localStorage.setItem(_this4._authDataKey, JSON.stringify(_this4._authData));\n\n        if (publicKey) {\n          yield _this4._moveKeyFromTempToPermanent(accountId, publicKey);\n        }\n      }\n\n      currentUrl.searchParams.delete('public_key');\n      currentUrl.searchParams.delete('all_keys');\n      currentUrl.searchParams.delete('account_id');\n      currentUrl.searchParams.delete('meta');\n      currentUrl.searchParams.delete('transactionHashes');\n      window.history.replaceState({}, document.title, currentUrl.toString());\n    })();\n  }\n  /**\n   * @hidden\n   * @param accountId The NEAR account owning the given public key\n   * @param publicKey The public key being set to the key store\n   */\n\n\n  _moveKeyFromTempToPermanent(accountId, publicKey) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const keyPair = yield _this5._keyStore.getKey(_this5._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n      yield _this5._keyStore.setKey(_this5._networkId, accountId, keyPair);\n      yield _this5._keyStore.removeKey(_this5._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    })();\n  }\n  /**\n   * Sign out from the current account\n   * @example\n   * walletAccount.signOut();\n   */\n\n\n  signOut() {\n    this._authData = {};\n    window.localStorage.removeItem(this._authDataKey);\n  }\n  /**\n   * Returns the current connected wallet account\n   */\n\n\n  account() {\n    if (!this._connectedAccount) {\n      this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n    }\n\n    return this._connectedAccount;\n  }\n\n}\n\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\n\nclass ConnectedWalletAccount extends account_1.Account {\n  constructor(walletConnection, connection, accountId) {\n    super(connection, accountId);\n    this.walletConnection = walletConnection;\n  } // Overriding Account methods\n\n  /**\n   * Sign a transaction by redirecting to the NEAR Wallet\n   * @see {@link WalletConnection.requestSignTransactions}\n   */\n\n\n  signAndSendTransaction(...args) {\n    if (typeof args[0] === 'string') {\n      return this._signAndSendTransaction({\n        receiverId: args[0],\n        actions: args[1]\n      });\n    }\n\n    return this._signAndSendTransaction(args[0]);\n  }\n\n  _signAndSendTransaction({\n    receiverId,\n    actions,\n    walletMeta,\n    walletCallbackUrl = window.location.href\n  }) {\n    var _superprop_getSignAndSendTransaction = () => super.signAndSendTransaction,\n        _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const localKey = yield _this6.connection.signer.getPublicKey(_this6.accountId, _this6.connection.networkId);\n      let accessKey = yield _this6.accessKeyForTransaction(receiverId, actions, localKey);\n\n      if (!accessKey) {\n        throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n      }\n\n      if (localKey && localKey.toString() === accessKey.public_key) {\n        try {\n          return yield _superprop_getSignAndSendTransaction().call(_this6, {\n            receiverId,\n            actions\n          });\n        } catch (e) {\n          if (e.type === 'NotEnoughAllowance') {\n            accessKey = yield _this6.accessKeyForTransaction(receiverId, actions);\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      const block = yield _this6.connection.provider.block({\n        finality: 'final'\n      });\n      const blockHash = borsh_1.baseDecode(block.header.hash);\n      const publicKey = utils_1.PublicKey.from(accessKey.public_key); // TODO: Cache & listen for nonce updates for given access key\n\n      const nonce = accessKey.access_key.nonce + 1;\n      const transaction = transaction_1.createTransaction(_this6.accountId, publicKey, receiverId, nonce, actions, blockHash);\n      yield _this6.walletConnection.requestSignTransactions({\n        transactions: [transaction],\n        meta: walletMeta,\n        callbackUrl: walletCallbackUrl\n      });\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(new Error('Failed to redirect to sign transaction'));\n        }, 1000);\n      }); // TODO: Aggregate multiple transaction request with \"debounce\".\n      // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    })();\n  }\n  /**\n   * Check if given access key allows the function call or method attempted in transaction\n   * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n   * @param receiverId The NEAR account attempting to have access\n   * @param actions The action(s) needed to be checked for access\n   */\n\n\n  accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        access_key: {\n          permission\n        }\n      } = accessKey;\n\n      if (permission === 'FullAccess') {\n        return true;\n      }\n\n      if (permission.FunctionCall) {\n        const {\n          receiver_id: allowedReceiverId,\n          method_names: allowedMethods\n        } = permission.FunctionCall;\n        /********************************\n        Accept multisig access keys and let wallets attempt to signAndSendTransaction\n        If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n        ********************************/\n\n        if (allowedReceiverId === _this7.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n          return true;\n        }\n\n        if (allowedReceiverId === receiverId) {\n          if (actions.length !== 1) {\n            return false;\n          }\n\n          const [{\n            functionCall\n          }] = actions;\n          return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && ( // TODO: Should support charging amount smaller than allowance?\n          allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)); // TODO: Handle cases when allowance doesn't have enough to pay for gas\n        }\n      } // TODO: Support other permissions than FunctionCall\n\n\n      return false;\n    })();\n  }\n  /**\n   * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n   * @param receiverId The NEAR account seeking the access key for a transaction\n   * @param actions The action(s) sought to gain access to\n   * @param localKey A local public key provided to check for access\n   * @returns Promise<any>\n   */\n\n\n  accessKeyForTransaction(receiverId, actions, localKey) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const accessKeys = yield _this8.getAccessKeys();\n\n      if (localKey) {\n        const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n\n        if (accessKey && (yield _this8.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n          return accessKey;\n        }\n      }\n\n      const walletKeys = _this8.walletConnection._authData.allKeys;\n\n      for (const accessKey of accessKeys) {\n        if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield _this8.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n          return accessKey;\n        }\n      }\n\n      return null;\n    })();\n  }\n\n}\n\nexports.ConnectedWalletAccount = ConnectedWalletAccount;","map":{"version":3,"sources":["C:/Users/Oleksandr Sai/source/repos/OlexandrSai/near--art--demo/node_modules/near-api-js/lib/wallet-account.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ConnectedWalletAccount","WalletAccount","WalletConnection","depd_1","require","account_1","transaction_1","utils_1","borsh_1","borsh_2","LOGIN_WALLET_URL_SUFFIX","MULTISIG_HAS_METHOD","LOCAL_STORAGE_KEY_SUFFIX","PENDING_ACCESS_KEY_PREFIX","constructor","near","appKeyPrefix","_near","authDataKey","authData","JSON","parse","window","localStorage","getItem","_networkId","config","networkId","_walletBaseUrl","walletUrl","contractName","_keyStore","connection","signer","keyStore","_authData","allKeys","_authDataKey","isSignedIn","_completeSignInWithAccessKey","accountId","getAccountId","requestSignIn","contractIdOrOptions","title","successUrl","failureUrl","options","deprecate","default","contractId","currentUrl","URL","location","href","newUrl","searchParams","set","contractAccount","account","state","accessKey","KeyPair","fromRandom","getPublicKey","toString","setKey","methodNames","forEach","methodName","append","assign","requestSignTransactions","args","Array","isArray","_requestSignTransactions","transactions","callbackUrl","meta","map","transaction","serialize","SCHEMA","serialized","Buffer","from","join","publicKey","get","split","setItem","stringify","_moveKeyFromTempToPermanent","delete","history","replaceState","document","keyPair","getKey","removeKey","signOut","removeItem","_connectedAccount","Account","walletConnection","signAndSendTransaction","_signAndSendTransaction","receiverId","actions","walletMeta","walletCallbackUrl","localKey","accessKeyForTransaction","Error","public_key","e","type","block","provider","finality","blockHash","baseDecode","header","hash","PublicKey","nonce","access_key","createTransaction","Promise","resolve","reject","setTimeout","accessKeyMatchesTransaction","permission","FunctionCall","receiver_id","allowedReceiverId","method_names","allowedMethods","includes","length","functionCall","deposit","accessKeys","getAccessKeys","find","key","walletKeys","indexOf"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst depd_1 = __importDefault(require(\"depd\"));\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst borsh_1 = require(\"borsh\");\nconst borsh_2 = require(\"borsh\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletAccount is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    async requestSignIn(contractIdOrOptions = {}, title, successUrl, failureUrl) {\n        let options;\n        if (typeof contractIdOrOptions === 'string') {\n            const deprecate = depd_1.default('requestSignIn(contractId, title)');\n            deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n            options = { contractId: contractIdOrOptions, successUrl, failureUrl };\n        }\n        else {\n            options = contractIdOrOptions;\n        }\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n        newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n        newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n        if (options.contractId) {\n            /* Throws exception if contract account does not exist */\n            const contractAccount = await this._near.account(options.contractId);\n            await contractAccount.state();\n            newUrl.searchParams.set('contract_id', options.contractId);\n            const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n        }\n        if (options.methodNames) {\n            options.methodNames.forEach(methodName => {\n                newUrl.searchParams.append('methodNames', methodName);\n            });\n        }\n        window.location.assign(newUrl.toString());\n    }\n    async requestSignTransactions(...args) {\n        if (Array.isArray(args[0])) {\n            const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n            deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n            return this._requestSignTransactions({\n                transactions: args[0],\n                callbackUrl: args[1],\n                meta: args[2]\n            });\n        }\n        return this._requestSignTransactions(args[0]);\n    }\n    async _requestSignTransactions({ transactions, meta, callbackUrl }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        if (meta)\n            newUrl.searchParams.set('meta', meta);\n        window.location.assign(newUrl.toString());\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    async _completeSignInWithAccessKey() {\n        const currentUrl = new URL(window.location.href);\n        const publicKey = currentUrl.searchParams.get('public_key') || '';\n        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n        const accountId = currentUrl.searchParams.get('account_id') || '';\n        // TODO: Handle errors during login\n        if (accountId) {\n            this._authData = {\n                accountId,\n                allKeys\n            };\n            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n            if (publicKey) {\n                await this._moveKeyFromTempToPermanent(accountId, publicKey);\n            }\n        }\n        currentUrl.searchParams.delete('public_key');\n        currentUrl.searchParams.delete('all_keys');\n        currentUrl.searchParams.delete('account_id');\n        currentUrl.searchParams.delete('meta');\n        currentUrl.searchParams.delete('transactionHashes');\n        window.history.replaceState({}, document.title, currentUrl.toString());\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    async _moveKeyFromTempToPermanent(accountId, publicKey) {\n        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        await this._keyStore.setKey(this._networkId, accountId, keyPair);\n        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletAccount.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection.requestSignTransactions}\n     */\n    signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });\n        }\n        return this._signAndSendTransaction(args[0]);\n    }\n    async _signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n        if (!accessKey) {\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n        }\n        if (localKey && localKey.toString() === accessKey.public_key) {\n            try {\n                return await super.signAndSendTransaction({ receiverId, actions });\n            }\n            catch (e) {\n                if (e.type === 'NotEnoughAllowance') {\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = borsh_1.baseDecode(block.header.hash);\n        const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n        // TODO: Cache & listen for nonce updates for given access key\n        const nonce = accessKey.access_key.nonce + 1;\n        const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n        await this.walletConnection.requestSignTransactions({\n            transactions: [transaction],\n            meta: walletMeta,\n            callbackUrl: walletCallbackUrl\n        });\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error('Failed to redirect to sign transaction'));\n            }, 1000);\n        });\n        // TODO: Aggregate multiple transaction request with \"debounce\".\n        // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        const { access_key: { permission } } = accessKey;\n        if (permission === 'FullAccess') {\n            return true;\n        }\n        if (permission.FunctionCall) {\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n            /********************************\n            Accept multisig access keys and let wallets attempt to signAndSendTransaction\n            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n            ********************************/\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                return true;\n            }\n            if (allowedReceiverId === receiverId) {\n                if (actions.length !== 1) {\n                    return false;\n                }\n                const [{ functionCall }] = actions;\n                return functionCall &&\n                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\n            }\n        }\n        // TODO: Support other permissions than FunctionCall\n        return false;\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n    async accessKeyForTransaction(receiverId, actions, localKey) {\n        const accessKeys = await this.getAccessKeys();\n        if (localKey) {\n            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        const walletKeys = this.walletConnection._authData.allKeys;\n        for (const accessKey of accessKeys) {\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        return null;\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n"]},"metadata":{},"sourceType":"script"}